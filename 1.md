# problem 1 - two sum 

leetcode easy

problem statement says that you are given an array of numbers, and a target they add up to, and are to return the indicies of the two numbers given 

the basic solution is clearly a two layer loop, brute force all the combos

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        int n = nums.size();
        vector<int> ans;

        for (int i=0; i<n; i++){
            for (int j=0; j<n; j++){
                if (nums[i]+nums[j]==target && i != j){
                    ans.push_back(i);
                    ans.push_back(j);
                    return ans;
                }
            }
        }

        return ans;
    }
};
```

next it wants me to get this under O(n^2), not sure how to do that at the moment, the list doesnt appear to be sorted in any way to help with that 

hint #2 says that we should consider value 1 fixed, and then shift the search to `v2 = target - v1` but I have no idea what you would set the target to thats guarenteed to be in the nums array

hint #3 mentions using a hashmap somehow, but I dont see how that works

ok somebody in the comments mentioned that you need to use a hashmap and store numbers as you come across them, so basically v1 is dynamic, but looking for v2 in the hashmap is O(1), so this is a linear solution now?

ahhh the key is the value and the value is a key, checking for the key is O(1) so make your values v2 the keys and their values the actual indexes

```cpp 
#include <map>

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        int n = nums.size();
        
        vector<int> ans;
        map<int, int> vk; // value-key instead

        for (int i=0; i<n; i++){
            
            int v1 = nums[i];
            int v2 = target - v1;

            if (vk.contains(v2)){
                ans.push_back(i);
                ans.push_back(vk[v2]);
            }

            vk[nums[i]] = i; // add the v1 key pair to the hashmap after check so future nums can check against it
        }

        return ans;
    }
};
```

this is the final outcome basically, this is O(N) 

ok wait turns out default cpp map is using a red-black tree, which makes this O(N log N)

to be O(N) I need to use unordered map, here:

```cpp
#include <unordered_map>

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        int n = nums.size();
        
        vector<int> ans;
        unordered_map<int, int> vk; // value-key instead

        for (int i=0; i<n; i++){
            
            int v1 = nums[i];
            int v2 = target - v1;

            if (vk.contains(v2)){
                ans.push_back(i);
                ans.push_back(vk[v2]);
            }

            vk[nums[i]] = i; // add the v1 key pair to the hashmap after check so future nums can check against it
        }

        return ans;
    }
};
```
