# problem 2 - add two numbers

leetcode medium

ohh okay so you get two linked lists that are storing all the digits, in reverse order, add the nodes back to the original, then sum up and remake the LL

you could do this with strings that hold the node values and typecast, but theres an assignment in cs 101 (eecs 168 at KU) that bans you from doing this and instead must reply on int tricks and modulo, and a couple years before this I saw an article from the TA side about this same problem from a guy at CMU (found the guy, it was jstrieb, learned about him from link pages, [the post](https://jstrieb.github.io/posts/digit-length/)), so I'm going to use modulos and magnitudes

LC gives you the listnode struct, not very good at reading these yet, but the premise is basically just using a pointer to the next value, feels a lot more concise than the pythonian equivalent of linking objects

ok so I have learned that the `->` operator lets you access the member of a pointer, basically the pointer equiv of `node.next` in python 

val and next are given by the struct

quick LL traversal:

```cpp
// traverse l1
while(l1 != nullptr){
    cout << l1->val << " ";
    l1 = l1->next; 
}
```

then converting the LL to a number with exponents:

```cpp
int n1 = 0;
int c = 0;

while(l1 != nullptr){
            
    int v = l1->val;
    n1 += v * pow(10, c);
    l1 = l1->next;
    c += 1; 
}
```

I got the modulo digits working, but with the way LL is defined it comes out reversed, like ans is 807 and i extract the digits in order [7,0,8], but LL sends it into reverse 

turns out when I thought I was post-pending I was actually pre-pending, prepending reverses it, need to use tail and head here 

taking me awhile to get used to the cpp pointer reference stuff, the `*` `->` `&` sort of make sense, feels pretty odd when you're used to python though 

this is what passes through initial tests:

```cpp 
#include <cmath>

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

        int n1 = 0;
        int n2 = 0;

        int c = 0;

        while(l1 != nullptr){
            
            int v = l1->val;
            n1 += v * pow(10, c);
            l1 = l1->next;
            c += 1; 
        }

        c = 0;

        while(l2 != nullptr){
            
            int v = l2->val;
            n2 += v * pow(10, c);
            l2 = l2->next;
            c += 1; 
        }

        int ans = n1+n2;

        ListNode* head = new ListNode(0);
        ListNode* tail = head;

        if (ans == 0){
            tail->next = new ListNode(0);
            tail = tail->next;
        }
        
        while (ans != 0){
            int digit = ans % 10;
            ans = ans/10;

            tail->next = new ListNode(digit); // Attach to the back
            tail = tail->next;
        }
        
        return head->next; // returns the second onward, [0,7,0,8] becomes [7,0,8]
    }
};
```

I turned all the `int` into `long long` but they specifically stuck a 1e100 case to ruin that, I assume this is to ruin my exponents and modulo idea and force me to stay in the LL the entire time, with a simulated addition+carry operation instead 

I have the pseudo for the carry figured out, will solve tomm.
